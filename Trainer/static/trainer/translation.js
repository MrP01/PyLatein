// Generated by CoffeeScript 1.9.3
var InputWidget, Result, Trainer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Result = (function(superClass) {
  extend(Result, superClass);

  function Result(translation) {
    this.translation = translation;
  }

  return Result;

})(AbstractResult);

InputWidget = (function(superClass) {
  extend(InputWidget, superClass);

  function InputWidget(inputId) {
    this.translation = $(inputId);
  }

  InputWidget.prototype.setResult = function(result) {
    return this.translation.val(result.translation);
  };

  InputWidget.prototype.getInput = function() {
    return new Result(this.translation.val());
  };

  InputWidget.prototype.isSkip = function() {
    var ref;
    return ((ref = this.translation.val()) === "?");
  };

  InputWidget.prototype.clear = function() {
    return this.translation.val("");
  };

  return InputWidget;

})(AbstractInputWidget);

Trainer = (function(superClass) {
  extend(Trainer, superClass);

  function Trainer() {
    return Trainer.__super__.constructor.apply(this, arguments);
  }

  Trainer.prototype.getPrompt = function(voc) {
    if (voc.model === "Vokabel.noun") {
      return voc.fields.sg1 + ", " + voc.fields.sg2 + " [" + voc.fields.genus + "] " + voc.fields.declination;
    } else if (voc.model === "Vokabel.verb") {
      return voc.fields.present_sg1 + ", " + voc.fields.present_sg2 + ", " + voc.fields.infinitive + ", " + voc.fields.perfect_sg1 + " " + voc.fields.conjugation;
    } else if (voc.model === "Vokabel.adjective") {
      return voc.fields.pos_sg1m + "/" + voc.fields.pos_sg1f + "/" + voc.fields.pos_sg1n + ", " + voc.fields.pos_sg2m + " " + voc.fields.declination;
    }
  };

  Trainer.prototype.getSolution = function(voc) {
    return new Result(voc.fields.translation);
  };

  Trainer.prototype.isCorrect = function(voc, result) {
    var i, len, ref, trans;
    result.translation = $.trim(result.translation).toLowerCase();
    ref = this.getSolution(voc).translation.split(",");
    for (i = 0, len = ref.length; i < len; i++) {
      trans = ref[i];
      trans = $.trim(trans).toLowerCase();
      if (trans === result.translation) {
        return true;
      }
    }
    return false;
  };

  return Trainer;

})(AbstractTrainer);

//# sourceMappingURL=translation.js.map
